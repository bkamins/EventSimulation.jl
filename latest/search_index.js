var documenterSearchIndex = {"docs":
[{"location":"reference/#reference","page":"EventSimulation Reference","title":"EventSimulation Reference","text":"","category":"section"},{"location":"reference/","page":"EventSimulation Reference","title":"EventSimulation Reference","text":"EventSimulation\nAction\nAbstractState\nEmptyState\nScheduler\nregister!\nrepeat_register!\nbulk_register!\nrepeat_bulk_register!\ninterrupt!\nterminate!\ngo!\nAbstractReservoir\nSimResource\nResourceRequest\nSimQueue\nrequest!\nwaive!\nprovide!\nwithdraw!\nPriorityTime","category":"page"},{"location":"reference/#EventSimulation","page":"EventSimulation Reference","title":"EventSimulation","text":"EventSimulation is an event-based discrete event simulation engine.\n\n\n\n\n\n","category":"module"},{"location":"reference/#EventSimulation.Action","page":"EventSimulation Reference","title":"EventSimulation.Action","text":"Structure holding an information that what should be executed by scheduler at time when; what should accept one argument of type Scheduler.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.AbstractState","page":"EventSimulation Reference","title":"EventSimulation.AbstractState","text":"Abstract type for holding state of the simulation\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.EmptyState","page":"EventSimulation Reference","title":"EventSimulation.EmptyState","text":"Simplest concrete type implementing AbstractState that does not hold any data\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.Scheduler","page":"EventSimulation Reference","title":"EventSimulation.Scheduler","text":"Holds information about current simulation state Contains the following fields:\n\nnow         current simulation time\nevent_queue priority queue of Actions planned to be executed\nstate       user defined subtype of AbstractState of the simulation\nmonitor     function that is called before event is triggered               must accept two arguments Scheduler and Δ, a difference               between time of event to be executed and time of last executed event\n\nIf two Actions have identical when time in event_queue then the order of their execution is undefined\n\nWhen monitor is executed the event to happen is still on event_queue, but time is updated to time when the event is to be executed (i.e. monitor sees the state of the simulation just before the event is triggered). Therefore for calculating summary statistics monitor may assume that the simulation spent Δ time in this state. Function monitor should not modify event_queue[1] as EventSimulation assumes that the event to be triggered after monitor executes will not be modified. Additionally it it not guaranteed that event_queue[1] will be executed after monitor finishes because simulation might terminate earlier.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.register!","page":"EventSimulation Reference","title":"EventSimulation.register!","text":"register!(s, what, Δ)\n\nPut what at time s.now+Δ to s.event_queue. what must accept exactly one argument of type Scheduler. The function does not check if Δ is a valid (finite) number. Returns inserted Action.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.repeat_register!","page":"EventSimulation Reference","title":"EventSimulation.repeat_register!","text":"repeat_register!(s, what, interval)\n\nPut what to s.event_queue repeatedly in time intervals specified by interval function, which must accept one argument of type Scheduler. what must accept exactly one argument of type Scheduler. interval function is called after the previous event was executed. Returns nothing. Calling terminate! in function interval will not stop the simulation. Instead, if interval returns nothing the action is not scheduled and repeat_register will effectively terminate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.bulk_register!","page":"EventSimulation Reference","title":"EventSimulation.bulk_register!","text":"bulk_register!(s, who, what, Δ, randomize)\n\nPut event at time s.now+Δ to s.event_queue that will execute what(scheduler, w) for all w in who. If randomize is false then who is traversed in natural order otherwise it is traversed in random order. what must accept exactly two arguments of type Scheduler and eltype(who). The function does not check if Δ is a valid (finite) number. Returns inserted bulk Action.\n\nFunction is designed to efficiently handle case when the same action has to be executed at the same simulation time by many agents.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.repeat_bulk_register!","page":"EventSimulation Reference","title":"EventSimulation.repeat_bulk_register!","text":"repeat_bulk_register!(s, who, what, interval, randomize)\n\nRepeat bulk_register! at time intervals specified by interval function, which must accept Scheduler argument. interval function is called after the previous event was executed. what must accept exactly two arguments of type Scheduler and typeof(who). Returns nothing. Calling terminate! in function interval will not stop the simulation. Instead, if interval returns nothing the action is not scheduled and repeat_register will effectively terminate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.interrupt!","page":"EventSimulation Reference","title":"EventSimulation.interrupt!","text":"interrupt!(s, a)\n\nFirst occurrence of Action a is replaced by no-op in event queue. This way there is no need to fix heap in this operation and it is fast. Returns true if a was found in queue and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.terminate!","page":"EventSimulation Reference","title":"EventSimulation.terminate!","text":"terminate!(s)\n\nEmpties s.event_queue which will lead to termination of simulation unless it is refilled before execution returns to go!. Useful for event-triggered termination of simulation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.go!","page":"EventSimulation Reference","title":"EventSimulation.go!","text":"go!(s, until)\n\nRuns simulation defined by s until s.now is greater or equal than until or s.event_queue is empty (i.e. nothing is left to be done). By default until equals Inf.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.AbstractReservoir","page":"EventSimulation Reference","title":"EventSimulation.AbstractReservoir","text":"Abstract class for reservoirs. SimQueue and SimResource are concrete types implementing it.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.SimResource","page":"EventSimulation Reference","title":"EventSimulation.SimResource","text":"Resource type for holding numeric values (like amount of liquid). It stores current quantity of matter and its allowed lo and hi amounts. Servers can get matter from the resource with optional maximum number of requests pending for fulfillment.\n\nFields:\n\nquantity       current quantity in resource\nlo            minimum quantity of resource\nhi            maximum quantity of resource\nfifo_requests if true requests is FIFO, otherwise LIFO\nmax_requests  maximum requests size\nrequests      vector of request and requested quantity\n\nFunctions in requests must accept one argument Scheduler, so they should know the amount they requested. When resource arrives to a queue there is a try to immediately dispatch it to pending requests. When new request arrives there is a try to immediately fulfill it.\n\nInitially an empty SimResource with no requests is constructed. Initial quantity, lo and hi may be provided. By default SimResource is empty, and has minimum quantity of zero and unbounded maximum.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.ResourceRequest","page":"EventSimulation Reference","title":"EventSimulation.ResourceRequest","text":"Internal structure that remembers that quantity was requested by request.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.SimQueue","page":"EventSimulation Reference","title":"EventSimulation.SimQueue","text":"SimQueue type for holding arbitrary objects O. It allows objects to be waiting in a queue with optional maximum queue size. Servers can get objects from the queue with optional maximum number of requests pending for fulfillment.\n\nFields:\n\nfifo_queue    if true queue is FIFO, otherwise LIFO\nmax_queue     maximum queue size\nqueue         vector of objects in a queue\nfifo_requests if true requests is FIFO, otherwise LIFO\nmax_requests  maximum requests size\nrequests      vector of request functions\n\nFunctions in requests must accept two arguments Scheduler and O. When O arrives to a queue there is a try to immediately feed it to pending requests. When new request arrives there is a try to immediately provide it with O.\n\nInitially an empty SimQueue with no requests is constructed. By default queue and requests have FIFO policy and are unbounded.\n\n\n\n\n\n","category":"type"},{"location":"reference/#EventSimulation.request!","page":"EventSimulation Reference","title":"EventSimulation.request!","text":"request!(s, r, quantity, request)\nrequest!(s, q, request)\n\nFunction used to register request for resource in SimResource or object from SimQueue.\n\nIn SimResource requested quantity must be provided and request accepts only Scheduler argument (it must know what it wanted). Returns tuple of:\n\ntrue if successfull and false when too many requests were made\nResourceRequest object created\n\nIn SimResource function request must accept one argument Scheduler. In SimQueue function request must accept two arguments Scheduler and object.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.waive!","page":"EventSimulation Reference","title":"EventSimulation.waive!","text":"waive!(r, res_request)\nwaive!(q, request)\n\nAllows to remove first occurence that would be served of res_request from SimResource or request from SimQueue.\n\nReturns true on success and false if res_request or request respectively was not found.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.provide!","page":"EventSimulation Reference","title":"EventSimulation.provide!","text":"provide!(s, r, quantity)\nprovide!(s, q, object)\n\nAllows to fill SimResource with quantity or SimQueue with object.\n\nIn SimResource changes the balance of r.quantity. Given quantity may be any number, but the balance of SimResource will be changed only in lo-hi range. Returns the actual change in SimResource balance.\n\nIn SimQueue adds object to q.queue. Returns true on success and false if there were too many objects in queue already.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.withdraw!","page":"EventSimulation Reference","title":"EventSimulation.withdraw!","text":"withdraw!(q, object)\n\nAllows to remove first occurrence that would be served of object from SimQueue.\n\nReturns true on success and false if object was not found.\n\n\n\n\n\n","category":"function"},{"location":"reference/#EventSimulation.PriorityTime","page":"EventSimulation Reference","title":"EventSimulation.PriorityTime","text":"Subtype of Real defining a lexicographically comparable pair of Real. It is designed to be used by Scheduler where standard real numbers run to a problem of undefined order of undefined order of removal from priority queue.\n\nPriorityTime two fields time and priority may have different types, but both have to be subtypes of Real. priority should be used to determine order of execution of Actions that have the same time. Two actions with identical time and priority have undefined oreder of execution so this should be avoided.\n\nPriorityTime type has defined lexicographic order and +, -. It is immutable, has a custom hash function and conversions from Real types.\n\n\n\n\n\n","category":"type"},{"location":"#EventSimulation.jl","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"","category":"section"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"An event based Discrete Event Simulation engine for Julia.","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"Intended as a support library for teaching basic principles of Discrete Event Simulation.","category":"page"},{"location":"#Package-features","page":"EventSimulation.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"register/interrupt execution of events\nresource (continuous homogenous good) reservoir\nqueue (arbitrary objects) reservoir","category":"page"},{"location":"#Examples","page":"EventSimulation.jl","title":"Examples","text":"","category":"section"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"A quick start tutorial can be found here.","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"Examples contained in /examples/ directory:","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"mm1_minimal.jl: a minimal M/M/1 queue implementaton\ngg1_minimal.jl: a minimal G/G/1 queue implementaton\nmms_example.jl: comparison of several implementations of M/M/s queue\nmm1_example.jl: basic implementation of M/M/1 queue with use of monitor\nbank_renege_1.jl: bank renege model (reimplementation of SimPy example)\nbank_renege_2.jl: bank renege model (reimplementation of SimPy example)\nmovie_renege.jl: movie renege model (reimplementation of SimPy example)\nfaxqueue.jl: a two-stage fax queue model; adaptation of B. Nelson (2013): Foundations and Methods of Stochastic Simulation, chap. 4.6, example\nseq_queue.jl: Experiment 4.1 from: C.-H. Chen, L.H. Lee (2011): Stochastic Simulation Optimization\nrepair.jl: a rewrite of SimJulia.jl example of S. Ross (2012): Simulation, 5th edition, Section 7.7, p. 124-126\ncomputer.jl: Example 2.5 from A. Law (2013): Simulation Modeling and Analysis, 5ed\nlookup.jl: model with s queues and s servers with different queue choice policies","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"The models that are reimplemnetation of SimPy run an order of magnitude (>20x) faster than in SimPy or SimJulia process oriented DES engines.","category":"page"},{"location":"#Quck-overview-of-EventSimulation-functionality","page":"EventSimulation.jl","title":"Quck overview of EventSimulation functionality","text":"","category":"section"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"General functionality","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"Action: information that a given function should be executed at given time\nAbstractState: abstract type used for holding global simulation state\nEmptyState: simplest empty concrete subtype of AbstractState\nScheduler: central object in the library jused to store information about event queue\nregister!: puts Action into Scheduler queue\nrepeat_register!: puts Action into Scheduler queue repeatedly\nbulk_register!: puts Action into Scheduler that will affect multiple objects\nrepeat_bulk_register!: puts Action into Scheduler that will affect multiple objects repeatedly\ninterrupt!: removes one given event from Scheduler queue\nterminate!: removes all events from Scheduler queue\ngo!: executes the simulation","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"Containers","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"AbstractReservoir: abstract type for defining reservoirs\nSimResource: reservoir for divisible and homogeneous matter\nResourceRequest: information about request for a resource\nSimQueue: reservoir for objects having unique identity\nrequest!: registers demand for a resource/object\nwaive!: remove registered request from waiting list\nprovide!: add resource/object to reservoir (or remove resource from SimResource)\nwithdraw!: remove object from SimQueue\nlength: number of objects in SimQueue","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"Utilities","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"PriorityTime: custom subtype of Real providing additional attribute priority to normal time. Useful for giving execution priority of events happening at the same time.","category":"page"},{"location":"","page":"EventSimulation.jl","title":"EventSimulation.jl","text":"Full documentation of types and functions defined in EventSimulation package can be found here.","category":"page"},{"location":"tutorial/#tutorial","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"","category":"section"},{"location":"tutorial/#Installation","page":"EventSimulation Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"In REPL run Pkg.add(\"EventSimulation\") to install the package and next using EventSimulation to start using it.","category":"page"},{"location":"tutorial/#First-simulation","page":"EventSimulation Tutorial","title":"First simulation","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"This is a bare minimum simulation using EventSimulation:","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\n\nfunction arrival(s)\n    t = s.now\n    println(\"Arrived at \", s.now)\n    register!(s, x -> println(\"Left at $(x.now) that arrived at $t\"), 1.5)\nend\n\ns = Scheduler()\nfor t in 1.0:5.0\n    register!(s, arrival, t)\nend\n\ngo!(s)","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"In this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in arrival we use a closure to define anonymous function that is registered. In its body x.now will be taken from the state of the scheduler when the anonymous function is invoked but t is fixed in enclosing scope of arrival function as the time of the arrival.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"When using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.","category":"page"},{"location":"tutorial/#Defining-infinite-source-of-events","page":"EventSimulation Tutorial","title":"Defining infinite source of events","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Now we add an infinite stream of customers arriving to the system:","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\n\nfunction arrival(s)\n    t = s.now\n    println(\"Arrived at \", s.now)\n    register!(s, x -> println(\"Left at $(x.now) that arrived at $t\"), 1.5)\nend\n\ns = Scheduler()\nrepeat_register!(s, arrival, x -> 1.0)\n\ngo!(s, 7)","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"In this example we show how arrival function can be scheduled to be repeatedly put into event queue in time deltas defined by anonymous function x -> 1.0.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Aslo observe that we have passed second argument 7 to function go! which will force unconditional termination of the simulation after this moment.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Exercise: Think what would happen if the termination time would be omitted in the expression go!(s, 7). How you could use function terminate! inside definition of arrival to get a similar effect. What would be the difference?","category":"page"},{"location":"tutorial/#Defining-custom-simulation-state","page":"EventSimulation Tutorial","title":"Defining custom simulation state","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Now let us add a simple counter of number of customers in the system:","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\nusing Random\n\nmutable struct CounterState <: AbstractState\n    count::Int\nend\n\nfunction arrival(s)\n    function departure(x)\n        x.state.count -= 1\n        println(\"Left at $(x.now) that arrived at $t and left \",\n                x.state.count, \" other customers\")\n    end\n\n    t = s.now\n    println(\"Arrived at \", s.now, \" and met \", s.state.count, \" other customers\")\n    register!(s, departure, 1.0)\n    s.state.count += 1\nend\n\ns = Scheduler(CounterState(0))\n\nRandom.seed!(1)\nrepeat_register!(s, arrival, x -> rand())\ngo!(s, 10)","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Observe that all functions in EventSimulation receive Scheduler as an argument and therefore they have acces to current simulation time and simulation state.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Additionally we have changed customer arrival behavior to random.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Exercise: Try changing customer's arrival rate to the exponential distribution using randexp function. Next change time in system distribution to the Gamma distribution. You can find it in Distributions package.","category":"page"},{"location":"tutorial/#Monitoring-simulation","page":"EventSimulation Tutorial","title":"Monitoring simulation","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Let us calculate how many customers are present in the above system using custom monitor.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\nusing Random\n\nmutable struct CounterState <: AbstractState\n    count::Int\n    total_time::Float64\n    customer_time::Float64\nend\n\nfunction arrival(s)\n    register!(s, departure, 1.0)\n    s.state.count += 1\nend\n\nfunction departure(s)\n    s.state.count -= 1\nend\n\nfunction monitor(s, Δ)\n    s.state.total_time += Δ\n    s.state.customer_time += Δ * s.state.count\nend\n\ncs = CounterState(0, 0.0, 0.0)\ns = Scheduler(cs, Float64, monitor)\n\nRandom.seed!(1)\nrepeat_register!(s, arrival, x -> rand())\ngo!(s, 100_000)\nprintln(\"Average number of customers in a system is \",\n        cs.customer_time/cs.total_time)","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Observe that monitor usually will modify simulation state to gather the simulation statistics. Other approaches could use global variables or variables defined in closure of monitor, but using simulation state is the recommended approach.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Exercise: Think if the obtained result is in line with Little's law. Try changing arrival rate and time in the system to check it. As a more advanced exercise make monitor collect data only when simulation time is greater or equal than 100 (i.e. discarding simulation burn-in period).","category":"page"},{"location":"tutorial/#Introduction-to-resources","page":"EventSimulation Tutorial","title":"Introduction to resources","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Now we will consider two streams of agents. Supplier provides one unit of good every one unit of time. There are customers that arrive randomly and want to buy a random amount of good. Maximally two customers can wait in the line.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\nusing Random\n\nmutable struct GoodState <: AbstractState\n    good::SimResource{Float64}\nend\n\nfunction delivery(s)\n    provide!(s, s.state.good, 1.0)\n    printstyled(\"Delivered 1.0 at \", s.now, \"\\n\", color=:green)\nend\n\nfunction customer(s)\n    function leave(x)\n        println(\"Left at \", x.now, \" with quantity \", round(demand, digits=4))\n    end\n    demand = rand()\n    print(\"Arrived at \", round(s.now, digits=4),\n          \" with demand \", round(demand, digits=4))\n    if !request!(s, s.state.good, demand, leave)[1]\n        printstyled(\" but line was too long and left with nothing\\n\", color=:red)\n    else\n        println(\" and went into a queue\")\n    end\nend\n\nfunction balance(s)\n    printstyled(\"Amount of good in storage: \", round(s.state.good.quantity, digits=4),\n                \" at time \", s.now, \"\\n\", color=:magenta)\nend\n\ns = Scheduler(GoodState(SimResource{Float64}(max_requests=2)))\n\nRandom.seed!(1)\nrepeat_register!(s, delivery, x -> 1.0)\nrepeat_register!(s, customer, x -> rand())\nrepeat_register!(s, balance, x -> x.now == 0 ? 1.000001 : 1.0)\ngo!(s, 5)","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Observe that fulfillment of pending requests by SimResource is immediate. This means that the amount is passed to a request from the container before the request event executed.","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Exercise: We have used a fixed value of 0.000001 as an increment over an integer number to invoke balance. Rewrite the example using PriorityTime type in such a way that balance is invoked at integer times but with priority low enough.","category":"page"},{"location":"tutorial/#Nothing-delta-in-repeat_register!","page":"EventSimulation Tutorial","title":"Nothing delta in repeat_register!","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"In general EventSimulation does not check the values passed to the engine in order to maximize execution speed. The only exception is interval argument of repeat_register! function. If it returns a value that is nothing then the repeated scheduling of events is interrupted. Here is a simple example","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\nusing Statistics\n\nmutable struct Jumps <: AbstractState\n    n::Int\nend\n\njump(s) = s.state.n+=1\nnext(s) = s.now >= 1.0 ? nothing : rand()\n\nfunction main()\n    s = Scheduler(Jumps(0))\n    repeat_register!(s, jump, next)\n    go!(s)\n    s.state.n\nend\n\nprintln(mean(main() for i in 1:10^6))","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"The above code implements a well known puzzle. Assume that we have a bug that gets hungry every rand() time units and eats then. Assume that the fist time it eats is 0. What is the expected number of times it will eat till time reaches 1.0? Run the code to learn the answer (if you did not know the puzzle before). Observe that returning nothing from next forces the simulation to stop.","category":"page"},{"location":"tutorial/#Bulk-execution-of-events","page":"EventSimulation Tutorial","title":"Bulk execution of events","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"EventSimulation allows you to plan execution of a batch of actions at the same time. They can be either executed in a predefined order or in random order (this example actually does not require DES, but is a MWE of bulk_register!).","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"using EventSimulation\nusing Statistics\nusing Random\n\nmutable struct Airplane <: AbstractState\n    free::Set{Int}\n    ok::Bool\nend\n\nfunction sit(s, i)\n    s.state.ok = i in s.state.free\n    pop!(s.state.free, s.state.ok ? i : rand(s.state.free))\nend\n\nfunction main(n)\n    s = Scheduler(Airplane(Set(1:n), false))\n    tickets = randperm(n)\n    tickets[1] = rand(1:n)\n    bulk_register!(s, tickets, sit, 0.0)\n    go!(s)\n    s.state.ok\nend\n\nfor n in [10, 50, 250]\n    println(n, \"\\t\", mean(main(n) for i in 1:10^4))\nend","category":"page"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"Another simple puzzle. We have an airplane with n seats and n customers. Every customer has a ticket with seat number. It is represented by a vector tickets. Customers enter the airplane in the order of the vector tickets and everyone tries to sit on ones own seat. Unfortunately tickets[1] = rand(1:n) so the firs customer has forgotten the seat number and has chosen a random seat. When the following customers enter the airplane and find their seat taken they pick a random free seat. The question is what is the probability that last customer that enters the plane finds the seat taken as a function of n. Run the simulation to find out if you do not know the answer!","category":"page"},{"location":"tutorial/#Next-steps","page":"EventSimulation Tutorial","title":"Next steps","text":"","category":"section"},{"location":"tutorial/","page":"EventSimulation Tutorial","title":"EventSimulation Tutorial","text":"This is the end of this introductory tutorial. More advanced features are covered in examples contained in /examples/ directory.","category":"page"}]
}
