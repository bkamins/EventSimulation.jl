<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EventSimulation Tutorial · EventSimulation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">EventSimulation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">EventSimulation.jl</a></li><li><a class="tocitem" href="../reference/">EventSimulation Reference</a></li><li class="is-active"><a class="tocitem" href>EventSimulation Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#First-simulation"><span>First simulation</span></a></li><li><a class="tocitem" href="#Defining-infinite-source-of-events"><span>Defining infinite source of events</span></a></li><li><a class="tocitem" href="#Defining-custom-simulation-state"><span>Defining custom simulation state</span></a></li><li><a class="tocitem" href="#Monitoring-simulation"><span>Monitoring simulation</span></a></li><li><a class="tocitem" href="#Introduction-to-resources"><span>Introduction to resources</span></a></li><li><a class="tocitem" href="#Nothing-delta-in-repeat_register!"><span><code>Nothing</code> delta in <code>repeat_register!</code></span></a></li><li><a class="tocitem" href="#Bulk-execution-of-events"><span>Bulk execution of events</span></a></li><li><a class="tocitem" href="#Next-steps"><span>Next steps</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>EventSimulation Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>EventSimulation Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bkamins/EventSimulation.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="tutorial"><a class="docs-heading-anchor" href="#tutorial">EventSimulation Tutorial</a><a id="tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>In REPL run <code>Pkg.add(&quot;EventSimulation&quot;)</code> to install the package and next <code>using EventSimulation</code> to start using it.</p><h2 id="First-simulation"><a class="docs-heading-anchor" href="#First-simulation">First simulation</a><a id="First-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#First-simulation" title="Permalink"></a></h2><p>This is a bare minimum simulation using EventSimulation:</p><pre><code class="language-none">using EventSimulation

function arrival(s)
    t = s.now
    println(&quot;Arrived at &quot;, s.now)
    register!(s, x -&gt; println(&quot;Left at $(x.now) that arrived at $t&quot;), 1.5)
end

s = Scheduler()
for t in 1.0:5.0
    register!(s, arrival, t)
end

go!(s)</code></pre><p>In this example five customers arrive at times 1, 2, ..., 5 and stay in the system for 1.5 time units. Observe that in <code>arrival</code> we use a closure to define anonymous function that is registered. In its body <code>x.now</code> will be taken from the state of the scheduler when the anonymous function is invoked but <code>t</code> is fixed in enclosing scope of <code>arrival</code> function as the time of the arrival.</p><p>When using EventSimulation working with closures is often the simplest way to develop a simulation so it is important that you understand this example.</p><h2 id="Defining-infinite-source-of-events"><a class="docs-heading-anchor" href="#Defining-infinite-source-of-events">Defining infinite source of events</a><a id="Defining-infinite-source-of-events-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-infinite-source-of-events" title="Permalink"></a></h2><p>Now we add an infinite stream of customers arriving to the system:</p><pre><code class="language-none">using EventSimulation

function arrival(s)
    t = s.now
    println(&quot;Arrived at &quot;, s.now)
    register!(s, x -&gt; println(&quot;Left at $(x.now) that arrived at $t&quot;), 1.5)
end

s = Scheduler()
repeat_register!(s, arrival, x -&gt; 1.0)

go!(s, 7)</code></pre><p>In this example we show how <code>arrival</code> function can be scheduled to be repeatedly put into event queue in time deltas defined by anonymous function <code>x -&gt; 1.0</code>.</p><p>Aslo observe that we have passed second argument <code>7</code> to function <code>go!</code> which will force unconditional termination of the simulation after this moment.</p><p><strong>Exercise</strong>: <em>Think what would happen if the termination time would be omitted in the expression <code>go!(s, 7)</code>. How you could use function <code>terminate!</code> inside definition of <code>arrival</code> to get a similar effect. What would be the difference?</em></p><h2 id="Defining-custom-simulation-state"><a class="docs-heading-anchor" href="#Defining-custom-simulation-state">Defining custom simulation state</a><a id="Defining-custom-simulation-state-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-custom-simulation-state" title="Permalink"></a></h2><p>Now let us add a simple counter of number of customers in the system:</p><pre><code class="language-none">using EventSimulation
using Random

mutable struct CounterState &lt;: AbstractState
    count::Int
end

function arrival(s)
    function departure(x)
        x.state.count -= 1
        println(&quot;Left at $(x.now) that arrived at $t and left &quot;,
                x.state.count, &quot; other customers&quot;)
    end

    t = s.now
    println(&quot;Arrived at &quot;, s.now, &quot; and met &quot;, s.state.count, &quot; other customers&quot;)
    register!(s, departure, 1.0)
    s.state.count += 1
end

s = Scheduler(CounterState(0))

Random.seed!(1)
repeat_register!(s, arrival, x -&gt; rand())
go!(s, 10)</code></pre><p>Observe that all functions in EventSimulation receive <code>Scheduler</code> as an argument and therefore they have acces to current simulation time and simulation state.</p><p>Additionally we have changed customer arrival behavior to random.</p><p><strong>Exercise</strong>: <em>Try changing customer&#39;s arrival rate to the exponential distribution using <code>randexp</code> function. Next change time in system distribution to the Gamma distribution. You can find it in <code>Distributions</code> package.</em></p><h2 id="Monitoring-simulation"><a class="docs-heading-anchor" href="#Monitoring-simulation">Monitoring simulation</a><a id="Monitoring-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Monitoring-simulation" title="Permalink"></a></h2><p>Let us calculate how many customers are present in the above system using custom <code>monitor</code>.</p><pre><code class="language-none">using EventSimulation
using Random

mutable struct CounterState &lt;: AbstractState
    count::Int
    total_time::Float64
    customer_time::Float64
end

function arrival(s)
    register!(s, departure, 1.0)
    s.state.count += 1
end

function departure(s)
    s.state.count -= 1
end

function monitor(s, Δ)
    s.state.total_time += Δ
    s.state.customer_time += Δ * s.state.count
end

cs = CounterState(0, 0.0, 0.0)
s = Scheduler(cs, Float64, monitor)

Random.seed!(1)
repeat_register!(s, arrival, x -&gt; rand())
go!(s, 100_000)
println(&quot;Average number of customers in a system is &quot;,
        cs.customer_time/cs.total_time)</code></pre><p>Observe that <code>monitor</code> usually will modify simulation state to gather the simulation statistics. Other approaches could use global variables or variables defined in closure of <code>monitor</code>, but using simulation state is the recommended approach.</p><p><strong>Exercise</strong>: <em>Think if the obtained result is in line with <a href="https://en.wikipedia.org/wiki/Little%27s_law">Little&#39;s law</a>. Try changing arrival rate and time in the system to check it. As a more advanced exercise make <code>monitor</code> collect data only when simulation time is greater or equal than 100 (i.e. discarding simulation burn-in period).</em></p><h2 id="Introduction-to-resources"><a class="docs-heading-anchor" href="#Introduction-to-resources">Introduction to resources</a><a id="Introduction-to-resources-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-resources" title="Permalink"></a></h2><p>Now we will consider two streams of agents. Supplier provides one unit of good every one unit of time. There are customers that arrive randomly and want to buy a random amount of good. Maximally two customers can wait in the line.</p><pre><code class="language-none">using EventSimulation
using Random

mutable struct GoodState &lt;: AbstractState
    good::SimResource{Float64}
end

function delivery(s)
    provide!(s, s.state.good, 1.0)
    printstyled(&quot;Delivered 1.0 at &quot;, s.now, &quot;\n&quot;, color=:green)
end

function customer(s)
    function leave(x)
        println(&quot;Left at &quot;, x.now, &quot; with quantity &quot;, round(demand, digits=4))
    end
    demand = rand()
    print(&quot;Arrived at &quot;, round(s.now, digits=4),
          &quot; with demand &quot;, round(demand, digits=4))
    if !request!(s, s.state.good, demand, leave)[1]
        printstyled(&quot; but line was too long and left with nothing\n&quot;, color=:red)
    else
        println(&quot; and went into a queue&quot;)
    end
end

function balance(s)
    printstyled(&quot;Amount of good in storage: &quot;, round(s.state.good.quantity, digits=4),
                &quot; at time &quot;, s.now, &quot;\n&quot;, color=:magenta)
end

s = Scheduler(GoodState(SimResource{Float64}(max_requests=2)))

Random.seed!(1)
repeat_register!(s, delivery, x -&gt; 1.0)
repeat_register!(s, customer, x -&gt; rand())
repeat_register!(s, balance, x -&gt; x.now == 0 ? 1.000001 : 1.0)
go!(s, 5)</code></pre><p>Observe that fulfillment of pending requests by <code>SimResource</code> is immediate. This means that the amount is passed to a request from the container before the request event executed.</p><p><strong>Exercise</strong>: <em>We have used a fixed value of <code>0.000001</code> as an increment over an integer number to invoke <code>balance</code>. Rewrite the example using <code>PriorityTime</code> type in such a way that <code>balance</code> is invoked at integer times but with priority low enough.</em></p><h2 id="Nothing-delta-in-repeat_register!"><a class="docs-heading-anchor" href="#Nothing-delta-in-repeat_register!"><code>Nothing</code> delta in <code>repeat_register!</code></a><a id="Nothing-delta-in-repeat_register!-1"></a><a class="docs-heading-anchor-permalink" href="#Nothing-delta-in-repeat_register!" title="Permalink"></a></h2><p>In general EventSimulation does not check the values passed to the engine in order to maximize execution speed. The only exception is <code>interval</code> argument of <code>repeat_register!</code> function. If it returns a value that is <code>nothing</code> then the repeated scheduling of events is interrupted. Here is a simple example</p><pre><code class="language-none">using EventSimulation
using Statistics

mutable struct Jumps &lt;: AbstractState
    n::Int
end

jump(s) = s.state.n+=1
next(s) = s.now &gt;= 1.0 ? nothing : rand()

function main()
    s = Scheduler(Jumps(0))
    repeat_register!(s, jump, next)
    go!(s)
    s.state.n
end

println(mean(main() for i in 1:10^6))</code></pre><p>The above code implements a well known puzzle. Assume that we have a bug that gets hungry every <code>rand()</code> time units and eats then. Assume that the fist time it eats is 0. What is the expected number of times it will eat till time reaches 1.0? Run the code to learn the answer (if you did not know the puzzle before). Observe that returning <code>nothing</code> from <code>next</code> forces the simulation to stop.</p><h2 id="Bulk-execution-of-events"><a class="docs-heading-anchor" href="#Bulk-execution-of-events">Bulk execution of events</a><a id="Bulk-execution-of-events-1"></a><a class="docs-heading-anchor-permalink" href="#Bulk-execution-of-events" title="Permalink"></a></h2><p>EventSimulation allows you to plan execution of a batch of actions at the same time. They can be either executed in a predefined order or in random order (this example actually does not require DES, but is a MWE of <code>bulk_register!</code>).</p><pre><code class="language-none">using EventSimulation
using Statistics
using Random

mutable struct Airplane &lt;: AbstractState
    free::Set{Int}
    ok::Bool
end

function sit(s, i)
    s.state.ok = i in s.state.free
    pop!(s.state.free, s.state.ok ? i : rand(s.state.free))
end

function main(n)
    s = Scheduler(Airplane(Set(1:n), false))
    tickets = randperm(n)
    tickets[1] = rand(1:n)
    bulk_register!(s, tickets, sit, 0.0)
    go!(s)
    s.state.ok
end

for n in [10, 50, 250]
    println(n, &quot;\t&quot;, mean(main(n) for i in 1:10^4))
end</code></pre><p>Another simple puzzle. We have an airplane with <code>n</code> seats and <code>n</code> customers. Every customer has a ticket with seat number. It is represented by a vector <code>tickets</code>. Customers enter the airplane in the order of the vector <code>tickets</code> and everyone tries to sit on ones own seat. Unfortunately <code>tickets[1] = rand(1:n)</code> so the firs customer has forgotten the seat number and has chosen a random seat. When the following customers enter the airplane and find their seat taken they pick a random free seat. The question is what is the probability that last customer that enters the plane finds the seat taken as a function of <code>n</code>. Run the simulation to find out if you do not know the answer!</p><h2 id="Next-steps"><a class="docs-heading-anchor" href="#Next-steps">Next steps</a><a id="Next-steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-steps" title="Permalink"></a></h2><p>This is the end of this introductory tutorial. More advanced features are covered in examples contained in <code>/examples/</code> directory.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reference/">« EventSimulation Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 May 2021 23:49">Tuesday 18 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
